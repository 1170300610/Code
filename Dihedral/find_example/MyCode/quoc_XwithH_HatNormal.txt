//given a list2[] and seqs[][]
//given a list indexsOfExactProduct element is index of which is exact product of dihedral Group.

for i in indexsOfExactProduct do
    G := list2[i];
    dihedralsForG := [];// This is for saving the exact product H and K for given G,element is a list
    sub_2n := [K`subgroup : K in Subgroups(G : OrderEqual := 2*n)];
    sub_2m := [K`subgroup : K in Subgroups(G : OrderEqual := 2*m)];
    for sub1 in sub_2n do
        for sub2 in sub_2m do
            if(IsIsomorphic(sub1,DihedralGroup(n)) and (IsIsomorphic(sub2,DihedralGroup(m)))) then
                product := {};
                for a in sub1 do
                    for b in sub2 do
                        Include(~product, a*b);
                    end for;
                end for;
                if #product eq 2*2*n*m then
                    Append(~dihedralsForG,[sub1,sub2]);
                    break sub1;//find the first one ,then break. You can all cancel this line to find all.
                end if;
            end if;
        end for;
    end for;

    H := dihedralsForG[1][1];
    K := dihedralsForG[1][2];
    a,b := DihedralGenerators(H);//find the generators
    c,d := DihedralGenerators(K);//alert if M contain a reflection ,this d might not be the one in M !!!!!

    c_X := Core(G,sub<K|c>);
    G_hat ,proj := quo<G | c_X>;
    H_hat := proj(H);//you can't get it by H/<c>_X since c is not even in H.
    flag_normal := IsNormal(G_hat,H_hat);
    central_c_X := Centralizer(G,c_X);
    flag_aInCentralize := a in central_c_X;
    flag_a2InCentralize := a^2 in central_c_X;
    flag1 := 0;
    flag2 := 0;
    flag3 := 0;
    if flag_normal then
        flag1 := 1;
    end if;
    if flag_aInCentralize then
        flag2 := 1;
    end if;
    if flag_a2InCentralize then
        flag3 := 1;
    end if;
    
    
    //deal with core M_X.
    maximalList := MaximalSubgroupContaining(G,H);
    if #maximalList eq 0 then 
        "error with maximalList";
    end if;
    
    flag4 := 0;
    flag5 := 0;
    M := maximalList[1];
    M_X := Core(G,M);
    G_hat2 ,proj2 := quo<G | M_X>;
    H_hat2 := proj2(H);
    c_hat2 := proj2(sub<K | c>);// to find out p.
    d_in_MCore := d in M_X;
    index_M_X := Index(G,M_X);
    H_in_MCore := H subset M_X;
    
    if d_in_MCore then
        flag4 := 1;
    end if;
    if H_in_MCore then
        flag5 := 1;
    end if;
    
    /*[
    1. index, 
    2. core size of c_X, 
    3. H/<c>_X is Normal in G/<c>_X, 
    4. a is in centerlizer of c_X,
    5. a is in centerlizer of c_X(should always 1),
    6. c/M_X order, 
    7. whether d is in M_Core,
    8. index of M_X in X(G),if occur 2 then M=M_X=<a,b><c> (if #c/M_X = 1)or <a,b><c^2,d> (if #c/M_X = 1),
    9. whether M_X contains H
    ].*/
    [i , #c_X , flag1 , flag2, flag3, #c_hat2, flag4, index_M_X, flag5];
end for;
