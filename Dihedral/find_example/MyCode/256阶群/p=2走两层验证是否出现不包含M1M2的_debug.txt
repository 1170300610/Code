/* construct indexsOfExactProduct2 and list*/

//n := 8;m := 8;
//indexsOfExactProduct2 := [717,720,725,3028,3060,3110,3126,3158,3174,3200,3210,3242,3286];//D8_D8



n := 4;m := 16;
/* 
5094 is a group can not factorize into exact product of DihedralGroup
5095 is a group do not contain a maximal group like <a,b><c1>
5139 is a group do not contain a maximal group like <a1><c,d>
5309 is a group do not contain a maximal group like <a,b><c1> and <a1><c,d>
 */
indexsOfExactProduct2 := [5094,5095,5139,5309];//D4_D16




//n := 2;m := 32;
//indexsOfExactProduct2 := [717,720,725,3028,3060,3110,3126,3158,3174,3200,3210,3242,3286];//D2_D32  TODO


list := SmallGroups(4*n*m,func<G|not IsAbelian(G) and IsSolvable(G)>);

/* end construct indexsOfExactProduct2 */



/* function start */
function isHKsubGroup(G, H, K)
    I := H meet K;
    S := sub<G | H,K>;
    if Order(S) eq (Order(H) * Order(K))/Order(I) then
        return true;
    end if;
    return false;
end function;

function CountElementsOfOrder(G, k)
    count := 0;
    for g in G do
        if Order(g) eq k then
            count +:= 1;
        end if;
    end for;
    return count;
end function;

function IsIsoDn(H,n)
/*
    if IsAbelian(H) then
        return false; 
    end if;
    if not IsSolvable(H) then
        return false;
    end if;
*/

    requiredOrder2 := (n mod 2 eq 0) select n+1 else n;
    if CountElementsOfOrder(H, 2) ne requiredOrder2 then 
        return false; 
    end if;
    
    if CountElementsOfOrder(H, n) ne EulerPhi(n) then
        return false;
    end if;
    
    hasCyclicIndex2 := false;
    for K in Subgroups(H : IndexEqual := 2) do
        if IsCyclic(K`subgroup) then
            hasCyclicIndex2 := true;
            break;
        end if;
    end for;
    
    if not hasCyclicIndex2 then 
        return false;
    end if;
    
    return IsIsomorphic(H,DihedralGroup(n));
    
end function;

function DihedralGenerators(H)
    for a in H do 
        for b in H do 
            if Order(a) eq #H/2 and Order(b) eq 2 then 
                H1 := sub<H | a,b>;
                if #H1 eq #H then 
                    return a,b;
                end if;
            end if;
        end for;
    end for;
    "logical error";
end function;



/*  H is the lower bound and H should be group.
    Return a list which element is group */
function MaximalSubgroupContaining(G,H)
    list := MaximalSubgroups(G);//list here is type SeqEnum, it computes when you use it.
    list_return := [];
    for M in list do
        if H subset M then
            Append(~list_return,M);
        end if;
    end for;
    return list_return;
end function;

/*  L is the lower bound,U is the upper bound. L and U can be set.
    Return a list which element is group */
function MaximalSubgroupBetween(G,L,U)
    list := MaximalSubgroups(G);//list here is type SeqEnum, it computes when you use it.
    list_return := [];
    for M in list do
        M_set := {a : a in M };
        L_set := {a : a in L };
        U_set := {a : a in U };
        if L_set subset M_set and M_set subset U_set then
            Append(~list_return,M);
        end if;
    end for;
    return list_return;
end function;

/* function end */




for i in indexsOfExactProduct2 do
    G := list[i];
    dihedralsForG := [];// This is for saving the exact product H and K for given G,element is a list
    sub_2n := [K`subgroup : K in Subgroups(G : OrderEqual := 2*n)];
    sub_2m := [K`subgroup : K in Subgroups(G : OrderEqual := 2*m)];
    subD2n := [];
    subD2m := [];
    for sub1 in sub_2n do
        if IsIsoDn(sub1,n) then
            Append(~subD2n,sub1);
        end if;
    end for;
    for sub2 in sub_2m do
        if IsIsoDn(sub2,m) then
            Append(~subD2m,sub2);
        end if;
    end for;
    for sub1 in subD2n do
        for sub2 in subD2m do
            if #(sub1 meet sub2) eq 1 then
                Append(~dihedralsForG,[sub1,sub2]);
                break sub1;
            end if;
        end for;
    end for;
    

    H := dihedralsForG[1][1];
    K := dihedralsForG[1][2];
    a,b := DihedralGenerators(H);//find the generators
    c,d := DihedralGenerators(K);
    
    M_l := MaximalSubgroupContaining(G,H);
    M_r := MaximalSubgroupContaining(G,K);
    flag1 := 0;
    flag2 := 0;
    flag3 := 0;
    flag4 := 0;
    
    //flag1 and flag2 
    maximalList1 := [];
    maximalList2 := [];
    for M in M_l do
        //flag1
        product_Hc2 := {};
        for x in H do
            for y in sub< G | c^2 > do
                Include(~product_Hc2, x*y);
            end for;
        end for;
        maximalList1 := MaximalSubgroupBetween(M,H,product_Hc2);
        
        //flag2
        if sub< K | c > subset M then
            "error1";
        elif not (sub< K | d > subset M) and not (sub< K | c*d > subset M) then
            "error2";
        elif sub< K | d > subset M then
            product := {};
            for x in sub< H | a > do
                for y in sub< G | c^2,d > do
                    Include(~product, x*y);
                end for;
            end for;
            maximalList2 := MaximalSubgroupBetween(M,sub< G | c^2,d >,product);//TODO
        elif sub< K | c*d > subset M then
            product := {};
            for x in sub< H | a > do
                for y in sub< G | c^2,c*d > do
                    Include(~product, x*y);
                end for;
            end for;
            maximalList2 := MaximalSubgroupBetween(M,sub< G | c^2,c*d >,product);//TODO
        end if;
        
        if #maximalList1 ne 0 then 
            flag1 := 1;
        end if;
        if #maximalList2 ne 0 then 
            flag2 := 1;
        end if;
    end for;
    
    
    //flag3 and flag4 
    maximalList3 := [];
    maximalList4 := [];
    for M in M_r do
        //flag3
        product_a2K := {};
        for x in sub<G | a^2> do
            for y in K do
                Include(~product_a2K, x*y);
            end for;
        end for;
        maximalList3 := MaximalSubgroupBetween(M,K,product_a2K);
        
        //flag4
        if sub< H | a > subset M then
            "error3";
        elif not (sub< H | b > subset M) and not (sub< H | a*b > subset M) then
            "error4";
        elif sub< H | b > subset M then
            product := {};
            for x in sub< H | a^2,b > do
                for y in sub< G | c > do
                    Include(~product, x*y);
                end for;
            end for;
            maximalList4 := MaximalSubgroupBetween(M,sub< H | a^2,b >,product);//TODO DONE
        elif sub< K | c*d > subset M then
            product := {};
            for x in sub< H | a^2,a*b > do
                for y in sub< G | c > do
                    Include(~product, x*y);
                end for;
            end for;
            maximalList4 := MaximalSubgroupBetween(M,sub< H | a^2,a*b >,product);//TODO DONE
        end if;
        
        if #maximalList3 ne 0 then 
            flag3 := 1;
        end if;
        if #maximalList4 ne 0 then 
            flag4 := 1;
        end if;
    end for;
    row := [i , flag1, flag2, flag3, flag4];
    printf "[";
    printf "%4o", row[1];
    for j := 2 to #row do
        printf ",%3o", row[j];
    end for;
    printf " ]\n";
end for;
