n := 4;
m := 8;

list := SmallGroups(4*n*m);



function SubgroupsBetween(G,L,U)
    list := [ N`subgroup : N in Subgroups(G)];
    L_set := {a : a in L };
    U_set := {a : a in U };
    list_return := [];
    for P in list do
        P_conjugates := Conjugates(G,P);
        for M in P_conjugates do 
            M_set := {a : a in M };
            if L_set subset M_set and M_set subset U_set then
                Append(~list_return,M);
            end if;
        end for;
    end for;
    return list_return;
end function;

function NontrivialMinimalNormalSubgroups(G)
    normSubs := NormalSubgroups(G);
    nonTrivialNormSubs := [ N`subgroup : N in normSubs | #N`subgroup gt 1 and #N`subgroup lt #G ];

    // 寻找极小正规子群：无其他非平凡正规子群严格包含于其中
    minimalNormals := [];
    for N in nonTrivialNormSubs do
        isMinimal := true;
        for M in nonTrivialNormSubs do
            if M ne N and M subset N then
                isMinimal := false;
                break;
            end if;
        end for;
        if isMinimal then
            Append(~minimalNormals, N);
        end if;
    end for;
    return minimalNormals;
end function;

function NontrivialAbelianMinimalNormalSubgroups(G)
    minimalAbelianNormals := [];
    minimalNormals := NontrivialMinimalNormalSubgroups(G);
    for N in minimalNormals do
        if IsAbelian(N) then
            Append(~minimalAbelianNormals,N);
        end if;
    end for;
    return minimalAbelianNormals;
end function;

procedure printList(row)
    printf "[";
    printf "%4o", row[1];
    for j := 2 to #row do
        printf ",%3o", row[j];
    end for;
    printf " ]\n";
end procedure;

/*  H is the lower bound and H should be group.
    Return a list which element is group */
function MaximalSubgroupContaining(G,H)
    list := MaximalSubgroups(G);//list here is type SeqEnum, it computes when you use it.
    list_return := [];
    for M in list do
        if H subset M then
            Append(~list_return,M);
        end if;
    end for;
    return list_return;
end function;

/*  L is the lower bound,U is the upper bound. L and U can be set.
    Return a list which element is group */
function MaximalSubgroupBetween(G,L,U)
    list := MaximalSubgroups(G);//list here is type SeqEnum, it computes when you use it.
    list_return := [];
    for M in list do
        M_set := {a : a in M };
        L_set := {a : a in L };
        U_set := {a : a in U };
        if L_set subset M_set and M_set subset U_set then
            Append(~list_return,M);
        end if;
    end for;
    return list_return;
end function;

function isHKsubGroup(G, H, K)
    I := H meet K;
    S := sub<G | H,K>;
    if Order(S) eq (Order(H) * Order(K))/Order(I) then
        return true;
    end if;
    return false;
end function;

function CountElementsOfOrder(G, k)
    count := 0;
    for g in G do
        if Order(g) eq k then
            count +:= 1;
        end if;
    end for;
    return count;
end function;

function IsIsoDn(H,n)
/*
    if IsAbelian(H) then
        return false; 
    end if;
    if not IsSolvable(H) then
        return false;
    end if;
*/
    //看K4的情况
    if n eq 2 and not IsCyclic(H) then
        return true;
    end if;
    
    
    requiredOrder2 := (n mod 2 eq 0) select n+1 else n;
    if CountElementsOfOrder(H, 2) ne requiredOrder2 then 
        return false; 
    end if;
    
    if CountElementsOfOrder(H, n) ne EulerPhi(n) then
        return false;
    end if;
    
    hasCyclicIndex2 := false;
    for K in Subgroups(H : IndexEqual := 2) do
        if IsCyclic(K`subgroup) then
            hasCyclicIndex2 := true;
            break;
        end if;
    end for;
    
    if not hasCyclicIndex2 then 
        return false;
    end if;
    
    return IsIsomorphic(H,DihedralGroup(n));
    
end function;

function DihedralGenerators(H)
    if #H eq 4 and not IsCyclic(H) then 
        ret := [a : a in H | Order(a) gt 1];
        return ret[1],ret[2];
    end if;

    for a in H do 
        for b in H do 
            if Order(a) eq #H/2 and Order(b) eq 2 then 
                H1 := sub<H | a,b>;
                if #H1 eq #H then 
                    return a,b;
                end if;
            end if;
        end for;
    end for;
    "logical error";
end function;





/*  H is the lower bound and H should be group.
    Return a list which element is group */
function MaximalSubgroupContaining(G,H)
    list := MaximalSubgroups(G);//list here is type SeqEnum, it computes when you use it.
    list_return := [];
    for M in list do
        if H subset M then
            Append(~list_return,M);
        end if;
    end for;
    return list_return;
end function;

/*  L is the lower bound,U is the upper bound. L and U can be set.
    Return a list which element is group */
function MaximalSubgroupBetween(G,L,U)
    list := MaximalSubgroups(G);//list here is type SeqEnum, it computes when you use it.
    list_return := [];
    for M in list do
        M_set := {a : a in M };
        L_set := {a : a in L };
        U_set := {a : a in U };
        if L_set subset M_set and M_set subset U_set then
            Append(~list_return,M);
        end if;
    end for;
    return list_return;
end function;


//load indexsOfExactProduct2
filename := "src/Paper/D8_D4/D8_D4_indexsOfExactProduct2.txt";
F := Open(filename,"r");
indexsOfExactProduct2 := [];
for i in [1 .. 60000] do
    line := Gets(F);
    if IsEof(line) then
        break;
    end if;
    Append(~indexsOfExactProduct2,StringToInteger(line));
end for;
delete F;


//多个分解
//given a list2[] and seqs[][]

ret := [];//用于存结果，每一行数据应该包含G的编号i及分解编号r

for i in indexsOfExactProduct2 do
    i;
    G := list[i];
    dihedralsForG := [];// This is for saving the exact product H and K for given G,element is a list
    sub_2n := [K`subgroup : K in Subgroups(G : OrderEqual := 2*n)];
    sub_2m := [K`subgroup : K in Subgroups(G : OrderEqual := 2*m)];
    subD2n := [];
    subD2m := [];
    for sub1 in sub_2n do
        if IsIsoDn(sub1,n) then
            Append(~subD2n,sub1);
        end if;
    end for;
    for sub2 in sub_2m do
        if IsIsoDn(sub2,m) then
            Append(~subD2m,sub2);
        end if;
    end for;
    for sub1 in subD2n do
        for sub2 in subD2m do
            if #(sub1 meet sub2) eq 1 then
                Append(~dihedralsForG,[sub1,sub2]);
            end if;
        end for;
    end for;
    
    for r in [1 .. #dihedralsForG] do
        H := dihedralsForG[r][1];
        K := dihedralsForG[r][2];
        a,b := DihedralGenerators(H);//find the generators
        c,d := DihedralGenerators(K);//alert if M contain a reflection ,this d might not be the one in M !!!!!

        //1. index.

        //2. M = <a,b><c1> in X.
        product_Hc := {};
        for a in H do
            for b in sub< G | c > do
                Include(~product_Hc, a*b);
            end for;
        end for;
        m1List := SubgroupsBetween(G,H,product_Hc);
        i_M1 := [];
        for sub in m1List do
            t := #(sub meet sub<G|c>);//o(c^i)
            Append(~i_M1,Order(c)/t);
        end for;
        
        smallest_i_M1 := 0;
        for t in i_M1 do
            if smallest_i_M1 eq 0 or t lt smallest_i_M1 then
                smallest_i_M1 := t;
            end if;
        end for;
        
        //3. M = <a1><c,d> in X.
        product_aK := {};
        for e1 in sub< G | a > do
            for e2 in K do
                Include(~product_aK, e1*e2);
            end for;
        end for;
        m2List := SubgroupsBetween(G,K,product_aK);
        i_M2 := [];
        for sub in m2List do
            t := #(sub meet sub<G|a>);//o(a^i)
            Append(~i_M2,Order(a)/t);
        end for;
        
        smallest_i_M2 := 0;
        index_M := 0;
        count := 0;
        for t in i_M2 do
            count := count + 1;
            if smallest_i_M2 eq 0 or t lt smallest_i_M2 then
                smallest_i_M2 := t;
                index_M := count;
            end if;
        end for;
        
        i1 := 0;//核中a的系数
        i2 := 0;//核中b的系数
        i3 := 0;//核中c的系数
        i4 := 0;//核中d的系数
        if smallest_i_M2 gt 0 then 
            M := m2List[index_M];
            M_X := Core(G,M);
            i1 := Order(a)/(#(M_X meet sub<G|a>));
            i2 := Order(b)/(#(M_X meet sub<G|b>));
            i3 := Order(c)/(#(M_X meet sub<G|c>));
            i4 := Order(d)/(#(M_X meet sub<G|d>));
        end if;
        
        cd_Corefree := 0;
        if #(Core(G,K)) eq 1 then
            cd_Corefree := 1;
        end if;
        
        //print
        row := [i,r,smallest_i_M2,i1,i2,i3,i4,cd_Corefree];
        Append(~ret,row);
        //printList(row);
    end for;
end for;
