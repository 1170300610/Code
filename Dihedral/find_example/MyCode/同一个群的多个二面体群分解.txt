/*  直接读取indexsOfExactProduct2.
    由于 indexsOfExactProduct2 中包含了所有有精确因子分解的群，这里的数量就比较少了，
    所以在这些群里边去找出所有二面体群分解的组合的代价不是特别高。
    改动：原来找到一个组合就break了，现在把群都存进dihedralsForG里，去遍历选取H和K.
        在选定了H和K之后，生成元a,b,c,d那就基本是确定了的，所以生成元那块不用改动。*/


/* read file */

//n := 8;m := 8;
//indexsOfExactProduct2 := [717,720,725,3028,3060,3110,3126,3158,3174,3200,3210,3242,3286];//D8_D8

n := 4;m := 16;
indexsOfExactProduct2 := [5083,5085,5309,6284,6290,6296,6299,6305,6311,6314,6316];//D4_D16

//n := 2;m := 32;
//indexsOfExactProduct2 := [717,720,725,3028,3060,3110,3126,3158,3174,3200,3210,3242,3286];//D2_D32  TODO

list := SmallGroups(4*n*m,func<G|not IsAbelian(G) and IsSolvable(G)>);
/* read file */

procedure printList(row)
    printf "[";
    printf "%4o", row[1];
    for j := 2 to #row do
        printf ",%3o", row[j];
    end for;
    printf " ]\n";
end procedure;

/*  H is the lower bound and H should be group.
    Return a list which element is group */
function MaximalSubgroupContaining(G,H)
    list := MaximalSubgroups(G);//list here is type SeqEnum, it computes when you use it.
    list_return := [];
    for M in list do
        if H subset M then
            Append(~list_return,M);
        end if;
    end for;
    return list_return;
end function;

/*  L is the lower bound,U is the upper bound. L and U can be set.
    Return a list which element is group */
function MaximalSubgroupBetween(G,L,U)
    list := MaximalSubgroups(G);//list here is type SeqEnum, it computes when you use it.
    list_return := [];
    for M in list do
        M_set := {a : a in M };
        L_set := {a : a in L };
        U_set := {a : a in U };
        if L_set subset M_set and M_set subset U_set then
            Append(~list_return,M);
        end if;
    end for;
    return list_return;
end function;

function isHKsubGroup(G, H, K)
    I := H meet K;
    S := sub<G | H,K>;
    if Order(S) eq (Order(H) * Order(K))/Order(I) then
        return true;
    end if;
    return false;
end function;

function CountElementsOfOrder(G, k)
    count := 0;
    for g in G do
        if Order(g) eq k then
            count +:= 1;
        end if;
    end for;
    return count;
end function;

function IsIsoDn(H,n)
/*
    if IsAbelian(H) then
        return false; 
    end if;
    if not IsSolvable(H) then
        return false;
    end if;
*/

    requiredOrder2 := (n mod 2 eq 0) select n+1 else n;
    if CountElementsOfOrder(H, 2) ne requiredOrder2 then 
        return false; 
    end if;
    
    if CountElementsOfOrder(H, n) ne EulerPhi(n) then
        return false;
    end if;
    
    hasCyclicIndex2 := false;
    for K in Subgroups(H : IndexEqual := 2) do
        if IsCyclic(K`subgroup) then
            hasCyclicIndex2 := true;
            break;
        end if;
    end for;
    
    if not hasCyclicIndex2 then 
        return false;
    end if;
    
    return IsIsomorphic(H,DihedralGroup(n));
    
end function;

function DihedralGenerators(H)
    for a in H do 
        for b in H do 
            if Order(a) eq #H/2 and Order(b) eq 2 then 
                H1 := sub<H | a,b>;
                if #H1 eq #H then 
                    return a,b;
                end if;
            end if;
        end for;
    end for;
    "logical error";
end function;


/*  H is the lower bound and H should be group.
    Return a list which element is group */
function MaximalSubgroupContaining(G,H)
    list := MaximalSubgroups(G);//list here is type SeqEnum, it computes when you use it.
    list_return := [];
    for M in list do
        if H subset M then
            Append(~list_return,M);
        end if;
    end for;
    return list_return;
end function;

/*  L is the lower bound,U is the upper bound. L and U can be set.
    Return a list which element is group */
function MaximalSubgroupBetween(G,L,U)
    list := MaximalSubgroups(G);//list here is type SeqEnum, it computes when you use it.
    list_return := [];
    for M in list do
        M_set := {a : a in M };
        L_set := {a : a in L };
        U_set := {a : a in U };
        if L_set subset M_set and M_set subset U_set then
            Append(~list_return,M);
        end if;
    end for;
    return list_return;
end function;



for i in indexsOfExactProduct2 do
    G := list[i];
    dihedralsForG := [];// This is for saving the exact product H and K for given G,element is a list
    sub_2n := [K`subgroup : K in Subgroups(G : OrderEqual := 2*n)];
    sub_2m := [K`subgroup : K in Subgroups(G : OrderEqual := 2*m)];
    subD2n := [];
    subD2m := [];
    for sub1 in sub_2n do
        if IsIsoDn(sub1,n) then
            Append(~subD2n,sub1);
        end if;
    end for;
    for sub2 in sub_2m do
        if IsIsoDn(sub2,m) then
            Append(~subD2m,sub2);
        end if;
    end for;
    for sub1 in subD2n do
        for sub2 in subD2m do
            if #(sub1 meet sub2) eq 1 then
                Append(~dihedralsForG,[sub1,sub2]);// delete break
            end if;
        end for;
    end for;
    
    
    for r in [1 .. #dihedralsForG] do
        H := dihedralsForG[r][1];
        K := dihedralsForG[r][2];
        a,b := DihedralGenerators(H);//find the generators
        c,d := DihedralGenerators(K);
        
        M_l := MaximalSubgroupContaining(G,H);
        M_r := MaximalSubgroupContaining(G,K);
        flag1 := 0;
        flag2 := 0;
        flag3 := 0;
        flag4 := 0;
        
        //flag1 and flag2 
        maximalList1 := [];
        maximalList2 := [];
        for M in M_l do
            //flag1
            maximalList1 := MaximalSubgroupContaining(M,H);
            
            //flag2
            if sub< K | c > subset M then
                "error1";
            elif not (sub< K | d > subset M) and not (sub< K | c*d > subset M) then
                "error2";
            elif sub< K | d > subset M then
                maximalList2 := MaximalSubgroupContaining(M,sub< G | c^2,d >);//TODO
            elif sub< K | c*d > subset M then
                maximalList2 := MaximalSubgroupContaining(M,sub< G | c^2,c*d >);//TODO
            end if;
        end for;
        
        
        //flag3 and flag4 
        maximalList3 := [];
        maximalList4 := [];
        for M in M_r do
            //flag3
            maximalList3 := MaximalSubgroupContaining(M,K);
            
            //flag4
            if sub< H | a > subset M then
                "error3";
            elif not (sub< H | b > subset M) and not (sub< H | a*b > subset M) then
                "error4";
            elif sub< H | b > subset M then
                maximalList4 := MaximalSubgroupContaining(M,sub< H | a^2,b >);//TODO DONE
            elif sub< H | a*b > subset M then//TODO DONE
                maximalList4 := MaximalSubgroupContaining(M,sub< H | a^2,a*b >);//TODO DONE
            end if;
        end for;
        
        
        
        
        
        //12. exist M = <a,b><c1> is maximal in X.
        flag_exist_Maximal := 0;
        product_Hc := {};
        for a in H do
            for b in sub< G | c > do
                Include(~product_Hc, a*b);
            end for;
        end for;
        maximalList2 := MaximalSubgroupBetween(G,H,product_Hc);
        if #maximalList2 ne 0 then
            flag_exist_Maximal := 1;
        end if;
        
        //13. exist M = <a1><c,d> is maximal in X.
        flag_exist_Maximal3 := 0;
        product_aK := {};
        for e1 in sub< G | a > do
            for e2 in K do
                Include(~product_aK, e1*e2);
            end for;
        end for;
        maximalList3 := MaximalSubgroupBetween(G,K,product_aK);
        if #maximalList3 ne 0 then
            flag_exist_Maximal3 := 1;
        end if;
        //print
        /*
        for T1 in maximalList1 do
            for T2 in maximalList2 do
                printList([i, 12, #(Core(G,T1) meet Core(G,T2))]);
            end for;
        end for;
        for T1 in maximalList1 do
            for T2 in maximalList3 do
                printList([i, 13, #(Core(G,T1) meet Core(G,T2))]);
            end for;
        end for;
        for T1 in maximalList1 do
            for T2 in maximalList4 do
                printList([i, 14, #(Core(G,T1) meet Core(G,T2))]);
            end for;
        end for;
        for T1 in maximalList2 do
            for T2 in maximalList3 do
                printList([i, 23, #(Core(G,T1) meet Core(G,T2))]);
            end for;
        end for;
        for T1 in maximalList2 do
            for T2 in maximalList4 do
                printList([i, 24, #(Core(G,T1) meet Core(G,T2))]);
            end for;
        end for;
        for T1 in maximalList3 do
            for T2 in maximalList4 do
                printList([i, 34, #(Core(G,T1) meet Core(G,T2))]);
            end for;
        end for;
        */
        
        row := [i , flag1, flag2, flag3, flag4, flag_exist_Maximal, flag_exist_Maximal3];
        printList(row);
    end for;
end for;
